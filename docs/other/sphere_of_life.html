<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.30">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Life-Projection Minima – Bezia Lemma</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-de070a7b0ab54f8780927367ac907214.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar floating fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../other/active_nematic_tennis.html">Other</a></li><li class="breadcrumb-item"><a href="../other/sphere_of_life.html">Life-Projection Minima</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Bezia Lemma</a> 
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Protocols</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../protocols/cryoslicing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Cryo-Embedding and Slicing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../protocols/immunostaining.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Crystal Immunostaining</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../protocols/lung_culture.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lung Culture</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Tutorials</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tutorials/install_julia.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Julia Quick Start</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tutorials/microscopy_training_checklist.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Microscopy Training Checklist</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tutorials/two_photon_microscopy.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Two-Photon Microscopy</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Stories</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../stories/annapurnacrescent.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Annapurna Crescent</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../stories/coexistence.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Coexistence</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../stories/first.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">First!</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../stories/mareksdisease.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Marek’s Disease</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Other</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../other/active_nematic_tennis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Active Nematic Tennis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../other/sphere_of_life.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Life-Projection Minima</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../other/active_nematic_tennis.html">Other</a></li><li class="breadcrumb-item"><a href="../other/sphere_of_life.html">Life-Projection Minima</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Life-Projection Minima</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="dimensions-of-life" class="level2">
<h2 class="anchored" data-anchor-id="dimensions-of-life">Dimensions of Life</h2>
<p>There are a lot of parameters to life. We might talk about it as highly-dimensional, not in terms of space and time, but in terms of all the parameters our life can move along. Some dimensions might be: How much money we have, our relationship with each loved one, the quality of our memories, the quality of our hopes and aspirations, how much muscle we have, how much fat we have, the quality of our health, how important we feel, how moral we feel, how content we feel, the amount we have contributed to society, etc. A lot of those dimensions of life contain dimensions in and of themselves. In such a vast parameter space, it is hard to understand how to optimize the short life you are given to be the best life you can have.</p>
<p>Let’s have a matrix, with some dimensions of life, and some normalized values from 0 to 1:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>Bez</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Money</td>
<td>0.1</td>
</tr>
<tr class="even">
<td>Fame</td>
<td>0.01</td>
</tr>
<tr class="odd">
<td># of hotdogs eaten</td>
<td>0.2</td>
</tr>
<tr class="even">
<td>Mean Happiness</td>
<td>0.4</td>
</tr>
<tr class="odd">
<td>Mean Unhappiness</td>
<td>0.7</td>
</tr>
</tbody>
</table>
<p>Some of these parameters higher numbers might be bad, some of them higher numbers might be good. For <span class="math inline">\(p_i\)</span> parameters, the optimization function of life is <span class="math inline">\(L(p_1, p_2, p_3, ..., p_i)\)</span>. Let’s go by golf rules and say that lower <span class="math inline">\(L\)</span> is better life.</p>
<p>Genetics also consists of a lot of dimensions. You have ~20,000 genes, and each gene can be expressed as RNA at a different density. Again there are sub-dimensions here, in that the RNA expression can vary spatially, but if we smudge that out how can we think about the state of cells through their genetics? An interesting (and by interesting I tend to mean difficult and dumb) technique that geneticists use is data reduction via the UMAP. UMAP (Uniform manifold approximation and projection) is a form of <a href="https://en.wikipedia.org/wiki/Nonlinear_dimensionality_reduction">nonlinear dimensionality reduction</a> that you can think of as a nonlinear version of <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">principle component analysis</a>. The idea of all these things is to bring down all those dimensions to two arbitrary dimensions. We brind down all the parameters, <span class="math inline">\(p_1, p_2, p_3, ...\)</span>, that the quality of life vary with into two parameters <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(\lambda_2\)</span>:</p>
<div class="text-center">
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Bez</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\lambda_1\)</span></td>
<td style="text-align: center;">0.6</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\lambda_2\)</span></td>
<td style="text-align: center;">0.4</td>
</tr>
</tbody>
</table>
</div>
<p>All the decisions in my life move me around in this two-dimensional space and change the values of <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(\lambda_2\)</span>. We’ve lost a tremendous amount of information by doing this, but now we can represent this life on a computer screen. Let there be a space <span class="math inline">\(L(\lambda_1, \lambda_2)\)</span> and say that we have defined these two parameters <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(\lambda_2\)</span> such that they are the angular coordinates of a sphere (they wrap back around on each themselves!). The spheroid with radius generated by <span class="math inline">\(L\)</span> represents the life you can have, of course the definition of <span class="math inline">\(L\)</span> evolves over the course of your life in some mysterious way. You want to find the minima, a lower <span class="math inline">\(L\)</span> is a better life. But you might find local minima instead. Or your minima that you found might change over time so that it becomes no longer the ideal minima.</p>
<p>Here is a sphere of life to move around on. Wht strategies give you the lowest minima? What about the lowest average minima?</p>


    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; font-family: 'Arial', sans-serif; background-color: #f0f0f0; }
        #sphereAppContainer {
            max-width: 600px; 
            width: 95%;     
            margin: 20px auto;
            border: 1px solid #ccc;
            padding: 10px;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.1);
            background-color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center; 
            position: relative; 
        }
        #canvasContainer { 
            position: relative;
            width: 100%;
            max-width: 600px; 
            aspect-ratio: 1 / 1; 
            margin-bottom: 10px;
        }
        #renderCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #ffffff; 
        }
        #runTimePercentDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 3.0em; /* User changed this */
            z-index: 10;
        }
        #radiusInfoDisplay {
            width: 100%;
            max-width: 600px;
            padding: 10px 0;
            margin-bottom: 10px;
            text-align: center;
            background-color: #f9f9f9;
            border-radius: 5px;
            border: 1px solid #eee;
        }
        #radiusInfoDisplay p {
            margin: 5px 0;
            font-size: 1.1em;
            color: #333;
        }
        #radiusInfoDisplay .label {
            font-weight: bold;
            color: #555;
        }
        #radiusInfoDisplay .value {
            color: #007bff;
        }
        #controls { /* This div now only contains instructions */
            background-color: #f0f0f0;
            color: #333;
            padding: 10px;
            border-radius: 5px;
            text-align: center; /* Centered instructions */
            width: calc(100% - 20px); 
            box-sizing: border-box;
            font-size: 0.9em;
            margin-bottom:10px; /* Added margin for spacing */
        }
        #controls p { 
            margin-top: 0;
        }
        #statsMenu {
            display: none; 
            position: absolute; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border: 1px solid #bbb;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 100;
            text-align: center;
            width: 80%;
            max-width: 350px;
        }
        #statsMenu h2 { margin-top: 0; color: #333; }
        #statsMenu p { margin: 8px 0; color: #555; font-size: 0.95em; }
        #statsMenu button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 20px;
            margin-top: 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }
        #statsMenu button:hover { background-color: #45a049; }
    </style>



    <div id="sphereAppContainer">
        <div id="controls">
            <p>Use mouse or touch to rotate around the origin.</p>
        </div>
        <div id="canvasContainer">
            <canvas id="renderCanvas"></canvas>
            <div id="runTimePercentDisplay">0%</div>
        </div>
        <div id="radiusInfoDisplay">
            <p><span class="label">Current Radius:</span> <span class="value" id="currentRDisplay">N/A</span></p>
            <p><span class="label">Lowest Radius:</span> <span class="value" id="lowestRDisplay">N/A</span></p>
        </div>
        
        <div id="statsMenu">
            <h2 class="anchored">Run Complete!</h2>
            <p>Lowest Radius: <span id="statLowestR">N/A</span></p>
            <p>Mean Radius: <span id="statMeanR">N/A</span></p>
            <p>Std Dev Radius: <span id="statStdDevR">N/A</span></p>
            <p>Max Radius: <span id="statMaxR">N/A</span></p>
            <button id="resetButton">Play Again</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, orbitControls;
        let noisySphere, playerDot, playerDotLight;

        const baseRadius = 5;
        const noiseAmplitude = 1.4;
        const noiseEvolutionSpeed = 0.1; 

        // Player's state
        let playerTheta = 0;
        let playerPhi = Math.PI / 2;
        let playerR = baseRadius;
        let lowestRadiusAchieved = Infinity;

        // Player physics state
        let playerVelTheta = 0.0;
        let playerVelPhi = 0.0;

        // Time tracking & Simulation State
        let physicsLastTime = performance.now(); 
        let globalTimeSeconds = 0; 
        let simulationStartTime = performance.now();
        const RUN_DURATION_SECONDS = 100;
        let simulationRunning = true;
        let animationFrameId;
        let radiusHistory = [];
        
        let runCount = 0; 
        let currentBaseHue = 0.66; 
        let isUserInteracting = false; 

        const K_GRAVITY = 3.0;
        const FRICTION_FACTOR = 0.95;
        const MIN_VELOCITY_THRESHOLD = 0.0001;
        const GRADIENT_DELTA_ANGLE = 0.01;
        const DOT_LERP_SPEED = 0.25; 
        const CAMERA_FOLLOW_LERP_SPEED = 0.08; // Slower LERP for camera auto-rotation

        const tempUnitVec = new THREE.Vector3(); 

        const MAX_TRAIL_SEGMENTS = 60;
        const TRAIL_SEGMENT_LIFETIME = 1.2; 
        const TRAIL_UPDATE_INTERVAL = 0.04; 
        let lastTrailUpdateTime = 0;
        const trailSegments = [];

        const sphereUpdate_tempVertex = new THREE.Vector3();
        const sphereUpdate_unitSpherePos = new THREE.Vector3();


        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff); 

            camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000); 
            camera.position.set(0, baseRadius * 0.5, baseRadius * 2.8);

            const canvas = document.getElementById('renderCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            
            const ambientLight = new THREE.AmbientLight(0xdddddd, 0.9); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); 
            directionalLight.position.set(1, 1.5, 1).normalize();
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4); 
            directionalLight2.position.set(-1, -0.5, -1).normalize();
            scene.add(directionalLight2);

            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05; 
            orbitControls.minDistance = baseRadius * 0.8;
            orbitControls.maxDistance = baseRadius * 5;
            orbitControls.target.set(0, 0, 0); 
            orbitControls.enablePan = false; 
            orbitControls.rotateSpeed = 0.1; 

            orbitControls.addEventListener('start', () => { 
                isUserInteracting = true; 
                // Target remains (0,0,0)
            });
            orbitControls.addEventListener('end', () => { 
                isUserInteracting = false; 
            });

            playerDot = createPlayerDot(); 
            if (playerDot) scene.add(playerDot);
            
            noisySphere = createNoisySphere(0); 
            if (noisySphere) scene.add(noisySphere);
            
            setupNewRun(); 

            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('resetButton').addEventListener('click', resetSimulation);
            
            onWindowResize(); 
            
            animationFrameId = requestAnimationFrame(animate); 
        }

        function setupNewRun() {
            simulationStartTime = performance.now();
            physicsLastTime = simulationStartTime;
            globalTimeSeconds = 0;
            radiusHistory = [];
            simulationRunning = true;
            isUserInteracting = false; 
            
            let dotHue;
            if (runCount === 0) {
                currentBaseHue = 0.66; 
                dotHue = 0.16;         
            } else {
                currentBaseHue = (currentBaseHue + 0.25) % 1.0; 
                dotHue = (currentBaseHue + 0.5) % 1.0;         
            }
            runCount++; 

            playerTheta = 0; 
            playerPhi = Math.PI / 2; 

            playerVelTheta = 0.0;
            playerVelPhi = 0.0;

            if (noisySphere) updateSphereGeometry(0); 
            if (playerDot) {
                const newDotColor = new THREE.Color().setHSL(dotHue, 0.95, 0.55);
                playerDot.material.color.copy(newDotColor);
                if (playerDotLight) playerDotLight.color.copy(newDotColor);
            }
            
            playerR = getHeightAt(playerTheta, playerPhi, 0); 
            lowestRadiusAchieved = playerR; 
            
            if(playerDot) playerDot.position.setFromSphericalCoords(playerR, playerPhi, playerTheta);
            
            orbitControls.target.set(0,0,0); 

            updateUIDisplays();
            document.getElementById('statsMenu').style.display = 'none';
        }

        function getNoiseValue(x, y, z, time) {
            let val = 0;
            const t = time * noiseEvolutionSpeed;
            const f1 = 8.0, f2 = 7.0, f3 = 10.4; 
            val += Math.sin(x * f1 + y * f2 + t * 1.1) * Math.cos(z * f1 + x * f3) * 0.4;
            val += Math.cos(y * f2 - z * f3 - t * 0.9) * Math.sin(x * f2 + y * f1) * 0.3;
            val += Math.sin(z * f3 + x * f1 - y * f2 + t * 1.3) * Math.cos(y * f3 - x * f2) * 0.3;
            val += Math.cos(x * 3.0 + t * 0.7) * Math.sin(y * 3.0 - t * 0.8) * 0.5; 
            val += Math.sin(z * 4.0 + t) * 0.3; 
            return val * 0.8;
        }

        function getHeightAt(theta, phi, time) {
            const safePhi = Math.max(0.0001, Math.min(Math.PI - 0.0001, phi));
            tempUnitVec.setFromSphericalCoords(1, safePhi, theta); 
            const noise = getNoiseValue(tempUnitVec.x, tempUnitVec.y, tempUnitVec.z, time);
            let r = baseRadius + noise * noiseAmplitude;
            return Math.max(0.1, r); 
        }

        function getColorForHeight(normalizedHeight) {
            const color = new THREE.Color();
            const saturation = 0.6 + normalizedHeight * 0.4; 
            const lightness = 0.4 + normalizedHeight * 0.3;  
            color.setHSL(currentBaseHue, saturation, lightness); 
            return color;
        }
        
        function createNoisySphere(initialTime) {
            const geometry = new THREE.SphereGeometry(baseRadius, 128, 64); 
            const positionAttribute = geometry.attributes.position;
            const colors = [];
            const minRForColor = baseRadius - noiseAmplitude;
            const maxRForColor = baseRadius + noiseAmplitude;

            for (let i = 0; i < positionAttribute.count; i++) {
                sphereUpdate_tempVertex.fromBufferAttribute(positionAttribute, i); 
                sphereUpdate_unitSpherePos.copy(sphereUpdate_tempVertex).normalize(); 
                const noise = getNoiseValue(sphereUpdate_unitSpherePos.x, sphereUpdate_unitSpherePos.y, sphereUpdate_unitSpherePos.z, initialTime);
                let currentRadius = baseRadius + noise * noiseAmplitude;
                currentRadius = Math.max(0.1, currentRadius);
                sphereUpdate_tempVertex.normalize().multiplyScalar(currentRadius);
                positionAttribute.setXYZ(i, sphereUpdate_tempVertex.x, sphereUpdate_tempVertex.y, sphereUpdate_tempVertex.z);
                const normalizedHeight = (currentRadius - minRForColor) / (maxRForColor - minRForColor);
                const vertexColor = getColorForHeight(Math.max(0, Math.min(1, normalizedHeight)));
                colors.push(vertexColor.r, vertexColor.g, vertexColor.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals(); 
            positionAttribute.needsUpdate = true; 
            const material = new THREE.MeshStandardMaterial({
                vertexColors: true, metalness: 0.05, roughness: 1.0, 
            });
            return new THREE.Mesh(geometry, material);
        }

        function updateSphereGeometry(currentTimeForNoise) {
            if (!noisySphere) return;
            const positions = noisySphere.geometry.attributes.position;
            const colors = noisySphere.geometry.attributes.color;
            const minRForColor = baseRadius - noiseAmplitude;
            const maxRForColor = baseRadius + noiseAmplitude;

            for (let i = 0; i < positions.count; i++) {
                sphereUpdate_tempVertex.fromBufferAttribute(positions, i);
                sphereUpdate_unitSpherePos.copy(sphereUpdate_tempVertex).normalize(); 
                const noise = getNoiseValue(sphereUpdate_unitSpherePos.x, sphereUpdate_unitSpherePos.y, sphereUpdate_unitSpherePos.z, currentTimeForNoise);
                let currentRadius = baseRadius + noise * noiseAmplitude;
                currentRadius = Math.max(0.1, currentRadius);
                sphereUpdate_tempVertex.copy(sphereUpdate_unitSpherePos).multiplyScalar(currentRadius); 
                positions.setXYZ(i, sphereUpdate_tempVertex.x, sphereUpdate_tempVertex.y, sphereUpdate_tempVertex.z);
                const normalizedHeight = (currentRadius - minRForColor) / (maxRForColor - minRForColor);
                const vertexColor = getColorForHeight(Math.max(0, Math.min(1, normalizedHeight))); 
                colors.setXYZ(i, vertexColor.r, vertexColor.g, vertexColor.b);
            }
            positions.needsUpdate = true;
            colors.needsUpdate = true;
            noisySphere.geometry.computeVertexNormals(); 
        }

        function createPlayerDot() {
            const dotGeometry = new THREE.SphereGeometry(0.12, 16, 8); 
            const dotMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 }); 
            const dotMesh = new THREE.Mesh(dotGeometry, dotMaterial);
            playerDotLight = new THREE.PointLight(0xffaa00, 2.5, baseRadius * 0.5); 
            dotMesh.add(playerDotLight); 
            return dotMesh;
        }

        function updatePlayerDotPosition() { 
            if (!playerDot) return;
            playerR = getHeightAt(playerTheta, playerPhi, globalTimeSeconds); 
            if (playerR < lowestRadiusAchieved) lowestRadiusAchieved = playerR;
            if (simulationRunning) radiusHistory.push(playerR);
            playerDot.position.setFromSphericalCoords(playerR, playerPhi, playerTheta);
        }
        
        function updateUIDisplays() {
            const percentComplete = Math.floor((globalTimeSeconds / RUN_DURATION_SECONDS) * 100);
            document.getElementById('runTimePercentDisplay').textContent = `${Math.min(100, Math.max(0,percentComplete))}%`;
            document.getElementById('currentRDisplay').textContent = playerR.toFixed(3);
            document.getElementById('lowestRDisplay').textContent = lowestRadiusAchieved === Infinity ? "N/A" : lowestRadiusAchieved.toFixed(3);
        }

        function applyGravity(deltaTime) {
            if (deltaTime <= 0) return;
            const h_current = getHeightAt(playerTheta, playerPhi, globalTimeSeconds); 
            const h_theta_plus = getHeightAt(playerTheta + GRADIENT_DELTA_ANGLE, playerPhi, globalTimeSeconds);
            const h_phi_plus = getHeightAt(playerTheta, playerPhi + GRADIENT_DELTA_ANGLE, globalTimeSeconds);
            let grad_R_dTheta = (h_theta_plus - h_current) / GRADIENT_DELTA_ANGLE;
            let grad_R_dPhi = (h_phi_plus - h_current) / GRADIENT_DELTA_ANGLE;
            let effectiveSinPhi = Math.sin(playerPhi);
            if (Math.abs(effectiveSinPhi) < 0.01) effectiveSinPhi = (effectiveSinPhi >= 0 ? 0.01 : -0.01);
            let acc_theta = -K_GRAVITY * grad_R_dTheta / (h_current * effectiveSinPhi);
            let acc_phi   = -K_GRAVITY * grad_R_dPhi / h_current;
            const max_acc_val = 10.0; 
            acc_theta = Math.max(-max_acc_val, Math.min(max_acc_val, acc_theta));
            acc_phi   = Math.max(-max_acc_val, Math.min(max_acc_val, acc_phi));
            playerVelTheta += acc_theta * deltaTime;
            playerVelPhi   += acc_phi * deltaTime;
            const friction = Math.pow(FRICTION_FACTOR, deltaTime * 60);
            playerVelTheta *= friction;
            playerVelPhi   *= friction;
            if (Math.abs(playerVelTheta) < MIN_VELOCITY_THRESHOLD) playerVelTheta = 0;
            if (Math.abs(playerVelPhi) < MIN_VELOCITY_THRESHOLD) playerVelPhi = 0;
            playerTheta += playerVelTheta * deltaTime;
            playerPhi   += playerVelPhi * deltaTime;
            playerPhi = Math.max(0.001, Math.min(Math.PI - 0.001, playerPhi)); 
            playerTheta = (playerTheta % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI); 
        }

        function updateTrail(deltaTime, currentTotalTimeInSeconds) {
            for (let i = trailSegments.length - 1; i >= 0; i--) {
                const segment = trailSegments[i];
                segment.age += deltaTime; 
                if (segment.age >= TRAIL_SEGMENT_LIFETIME) {
                    scene.remove(segment.mesh);
                    if (segment.mesh.geometry) segment.mesh.geometry.dispose();
                    if (segment.mesh.material) segment.mesh.material.dispose();
                    trailSegments.splice(i, 1);
                } else {
                    const lifeRatio = segment.age / TRAIL_SEGMENT_LIFETIME;
                    segment.mesh.material.opacity = 0.85 * (1.0 - lifeRatio * lifeRatio); 
                    segment.mesh.scale.setScalar(Math.max(0.05, 1.0 - lifeRatio * 0.85)); 
                }
            }
            const speed = Math.sqrt(playerVelTheta * playerVelTheta + playerVelPhi * playerVelPhi);
            const minSpeedForTrail = 0.01; 
            if (speed > minSpeedForTrail && (currentTotalTimeInSeconds * 1000 - lastTrailUpdateTime > TRAIL_UPDATE_INTERVAL * 1000 )) {
                 if (trailSegments.length >= MAX_TRAIL_SEGMENTS) {
                    const oldestSegment = trailSegments.shift(); 
                    scene.remove(oldestSegment.mesh);
                    if (oldestSegment.mesh.geometry) oldestSegment.mesh.geometry.dispose();
                    if (oldestSegment.mesh.material) oldestSegment.mesh.material.dispose();
                }
                const trailSegmentGeo = new THREE.SphereGeometry(0.06, 8, 4);
                const trailSegmentMat = new THREE.MeshBasicMaterial({
                    color: playerDot.material.color, 
                    transparent: true, opacity: 0.85 
                });
                const trailMesh = new THREE.Mesh(trailSegmentGeo, trailSegmentMat);
                trailMesh.position.copy(playerDot.position); 
                scene.add(trailMesh);
                trailSegments.push({ mesh: trailMesh, age: 0 });
                lastTrailUpdateTime = currentTotalTimeInSeconds * 1000; 
            }
        }

        function calculateStatistics() {
            if (radiusHistory.length === 0) return { min: lowestRadiusAchieved, max: 0, mean: 0, stdDev: 0 };
            const sum = radiusHistory.reduce((acc, val) => acc + val, 0);
            const mean = sum / radiusHistory.length;
            const max = Math.max(...radiusHistory);
            const squaredDifferences = radiusHistory.map(val => Math.pow(val - mean, 2));
            const variance = squaredDifferences.reduce((acc, val) => acc + val, 0) / radiusHistory.length;
            const stdDev = Math.sqrt(variance);
            return { min: lowestRadiusAchieved, max, mean, stdDev };
        }

        function showStatisticsMenu() {
            const stats = calculateStatistics();
            document.getElementById('statLowestR').textContent = stats.min.toFixed(3);
            document.getElementById('statMeanR').textContent = stats.mean.toFixed(3);
            document.getElementById('statStdDevR').textContent = stats.stdDev.toFixed(3);
            document.getElementById('statMaxR').textContent = stats.max.toFixed(3);
            document.getElementById('statsMenu').style.display = 'block';
        }

        function resetSimulation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            setupNewRun(); 
            animationFrameId = requestAnimationFrame(animate); 
        }
        
        function onWindowResize() {
            const canvasContainer = document.getElementById('canvasContainer');
            const appContainer = document.getElementById('sphereAppContainer');
            let availableWidth = appContainer.clientWidth - parseFloat(getComputedStyle(appContainer).paddingLeft) - parseFloat(getComputedStyle(appContainer).paddingRight);
            availableWidth = Math.min(600, availableWidth); 
            canvasContainer.style.width = availableWidth + 'px';
            canvasContainer.style.height = availableWidth + 'px'; 
            camera.aspect = 1; 
            camera.updateProjectionMatrix();
            renderer.setSize(availableWidth, availableWidth);
        }

        function animate(timestamp) {
            if (!simulationRunning) { renderer.render(scene, camera); return; }
            animationFrameId = requestAnimationFrame(animate); 
            
            const physicsDeltaTime = Math.min(0.1, (timestamp - physicsLastTime) * 0.001);
            physicsLastTime = timestamp;
            globalTimeSeconds = (timestamp - simulationStartTime) * 0.001; 

            if (globalTimeSeconds >= RUN_DURATION_SECONDS) {
                simulationRunning = false;
                globalTimeSeconds = RUN_DURATION_SECONDS; 
                updateSphereGeometry(globalTimeSeconds); 
                updatePlayerDotPosition(); 
                updateUIDisplays(); 
                showStatisticsMenu();
                // For the end screen, ensure camera looks at the final dot position while orbiting origin
                const endDistance = orbitControls.getDistance();
                camera.position.setFromSphericalCoords(endDistance, playerPhi, playerTheta);
                camera.lookAt(orbitControls.target); // Target is (0,0,0)
                renderer.render(scene, camera);
                return; 
            }
            
            orbitControls.update(); // Process user input and damping

            if (isUserInteracting) {
                // User is controlling the camera. Dot LERPs to view center.
                let targetPlayerTheta = (orbitControls.getAzimuthalAngle() % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);
                let targetPlayerPhi = orbitControls.getPolarAngle();
                targetPlayerPhi = Math.max(0.001, Math.min(Math.PI - 0.001, targetPlayerPhi));

                let deltaTheta = targetPlayerTheta - playerTheta;
                if (deltaTheta > Math.PI) deltaTheta -= 2 * Math.PI;
                if (deltaTheta < -Math.PI) deltaTheta += 2 * Math.PI;
                playerTheta += deltaTheta * DOT_LERP_SPEED;
                playerTheta = (playerTheta % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);
                playerPhi += (targetPlayerPhi - playerPhi) * DOT_LERP_SPEED;
                
                playerVelTheta = 0; 
                playerVelPhi = 0;
            } else {
                // User is idle. Apply physics.
                if (physicsDeltaTime > 0) {
                    applyGravity(physicsDeltaTime); // This updates playerTheta, playerPhi due to roll
                }
                // Camera auto-rotates to follow the new playerTheta, playerPhi
                const currentDistance = orbitControls.getDistance();
                const currentCamTheta = (orbitControls.getAzimuthalAngle() % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);
                const currentCamPhi = orbitControls.getPolarAngle();

                let targetCamTheta = playerTheta; // Camera should aim where the dot is
                let targetCamPhi = playerPhi;

                let deltaTheta = targetCamTheta - currentCamTheta;
                if (deltaTheta > Math.PI) deltaTheta -= 2 * Math.PI;
                if (deltaTheta < -Math.PI) deltaTheta += 2 * Math.PI;
                
                let newCamTheta = currentCamTheta + deltaTheta * CAMERA_FOLLOW_LERP_SPEED;
                newCamTheta = (newCamTheta % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);
                let newCamPhi = currentCamPhi + (targetCamPhi - currentCamPhi) * CAMERA_FOLLOW_LERP_SPEED;
                newCamPhi = Math.max(0.001, Math.min(Math.PI - 0.001, newCamPhi));

                camera.position.setFromSphericalCoords(currentDistance, newCamPhi, newCamTheta);
                camera.lookAt(orbitControls.target); // Target is always (0,0,0)
            }
            
            updateSphereGeometry(globalTimeSeconds);
            updatePlayerDotPosition(); // Update dot mesh to its final (aimed or rolled) position

            if (physicsDeltaTime > 0) { // Trail is based on rolling velocity
                 updateTrail(physicsDeltaTime, timestamp * 0.001); 
            }
            
            updateUIDisplays(); 
            renderer.render(scene, camera);
        }
        init();
    </script>





</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>
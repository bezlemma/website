---
title: "Life-Projection Minima"
format:
  html:
    toc: false
---

## A UMAP of Life

There are a lot of parameters to life. We might talk about it as highly-dimensional, not in terms of space and time, but in terms of all the parameters our life can move along. Some dimensions might be: How much money we have, our relationship with each loved one, the quality of our memories, the quality of our hopes and asperations, how much muscle we have, how much fat we have, the quality of our health, how important we feel, how moral we feel, how content we feel, the amount we have contributed to society, etc. A lot of those dimensions of life contain dimensions in and of themselves. In such a vast paramter space, it is hard to understand how to optimize the short life you are given to be the best life you can have.

Let's have a matrix, with some dimensions of life, and some normalized values from 0 to 1:

|          | Bez |
|----------|----------|
| Money              | 0.1  |
| Fame               | 0.01 |
| # of hotdogs eaten | 0.2  |
| Mean Happiness     | 0.4  |
| Mean Unhappiness   | 0.7  |

Some of these parameteres higher numbers might be bad, some of them higher numebers might be good. For $p_i$ parameters, the optimizaiton function of life is $L(p_1, p_2, p_3, ..., p_i)$. Let's go by golf rules and say that lower $L$ is better life. 

Genetics also consists of a lot of paramters. You have ~20,000 genes, and each gene can be expressed as RNA at a different density. Again there are sub-dimensions here, in that the RNA expression can vary spatially, but if we smudge that out how can we think about the state of cells through their genetics? An interesting (and by interesteing I tend to mean difficult and dumb) technique that geneticists use is data reduction via the UMAP. UMAP (Uniform manifold approximation and projection) is a form of [nonlinear dimensionality reduction](https://en.wikipedia.org/wiki/Nonlinear_dimensionality_reduction) that you can think of as a nonlinear version of [principle componenet analysis](https://en.wikipedia.org/wiki/Principal_component_analysis). The idea of all these things is to bring down all those dimensions to two arbitrary dimensions that the quality of life vary with, which I will call $\lambda_1$ and $\lambda_2$:

::: {.text-center}
|          | Bez |
|:--------:|:---:|
| $\lambda_1$ | 0.6 |
| $\lambda_2$ | 0.4 |
:::

All the deicisions in my life move me around in this two-dimensional space and change the values of $\lambda_1$ and $\lambda_2$. We've lost a tremendous amount of information by doing this, but now we can represent this life on a computer screen. Let there be a space $L(\lambda_1, \lambda_2)$ and say that we have defined these two paramteres $\lambda_1$ and $\lambda_2$ such that they are the angular coordinates of a sphere (they wrap back around on each themselves!). The spheroid with radius generated by $L$ represents the life you can have, of course the definition of $L$ evolves over the course of your life in some mysterious way. You want to find the minima, a lower $L$ is a better life. But you might find local minima instead. Or your minima that you found might change over time so that it becomes no longer the ideal minima.

Here is a sphere of life to move around on. Wht strategies give you the lowest minima? What about the lowest average minima?


```{=html}
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; font-family: 'Arial', sans-serif; background-color: #f0f0f0; }
        #sphereAppContainer {
            max-width: 600px; 
            width: 95%;     
            margin: 20px auto;
            border: 1px solid #ccc;
            padding: 10px;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.1);
            background-color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center; 
            position: relative; 
        }
        #canvasContainer { 
            position: relative;
            width: 100%;
            max-width: 600px; 
            aspect-ratio: 1 / 1; 
            margin-bottom: 10px;
        }
        #renderCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #ffffff; 
        }
        #runTimePercentDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 3.0em; /* User changed this */
            z-index: 10;
        }
        #radiusInfoDisplay {
            width: 100%;
            max-width: 600px;
            padding: 10px 0;
            margin-bottom: 10px;
            text-align: center;
            background-color: #f9f9f9;
            border-radius: 5px;
            border: 1px solid #eee;
        }
        #radiusInfoDisplay p {
            margin: 5px 0;
            font-size: 1.1em;
            color: #333;
        }
        #radiusInfoDisplay .label {
            font-weight: bold;
            color: #555;
        }
        #radiusInfoDisplay .value {
            color: #007bff;
        }
        #controls { /* This div now only contains instructions */
            background-color: #f0f0f0;
            color: #333;
            padding: 10px;
            border-radius: 5px;
            text-align: center; /* Centered instructions */
            width: calc(100% - 20px); 
            box-sizing: border-box;
            font-size: 0.9em;
            margin-bottom:10px; /* Added margin for spacing */
        }
        #controls p { 
            margin-top: 0;
        }
        #statsMenu {
            display: none; 
            position: absolute; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border: 1px solid #bbb;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 100;
            text-align: center;
            width: 80%;
            max-width: 350px;
        }
        #statsMenu h2 { margin-top: 0; color: #333; }
        #statsMenu p { margin: 8px 0; color: #555; font-size: 0.95em; }
        #statsMenu button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 20px;
            margin-top: 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }
        #statsMenu button:hover { background-color: #45a049; }
    </style>
</head>
<body>

    <div id="sphereAppContainer">
        <div id="controls">
            <p>Use mouse or touch to rotate around the origin.</p>
        </div>
        <div id="canvasContainer">
            <canvas id="renderCanvas"></canvas>
            <div id="runTimePercentDisplay">0%</div>
        </div>
        <div id="radiusInfoDisplay">
            <p><span class="label">Current Radius:</span> <span class="value" id="currentRDisplay">N/A</span></p>
            <p><span class="label">Lowest Radius:</span> <span class="value" id="lowestRDisplay">N/A</span></p>
        </div>
        
        <div id="statsMenu">
            <h2>Run Complete!</h2>
            <p>Lowest Radius: <span id="statLowestR">N/A</span></p>
            <p>Mean Radius: <span id="statMeanR">N/A</span></p>
            <p>Std Dev Radius: <span id="statStdDevR">N/A</span></p>
            <p>Max Radius: <span id="statMaxR">N/A</span></p>
            <button id="resetButton">Play Again</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, orbitControls;
        let noisySphere, playerDot, playerDotLight;

        const baseRadius = 5;
        const noiseAmplitude = 1.4;
        const noiseEvolutionSpeed = 0.1; 

        // Player's state
        let playerTheta = 0;
        let playerPhi = Math.PI / 2;
        let playerR = baseRadius;
        let lowestRadiusAchieved = Infinity;

        // Player physics state
        let playerVelTheta = 0.0;
        let playerVelPhi = 0.0;

        // Time tracking & Simulation State
        let physicsLastTime = performance.now(); 
        let globalTimeSeconds = 0; 
        let simulationStartTime = performance.now();
        const RUN_DURATION_SECONDS = 100;
        let simulationRunning = true;
        let animationFrameId;
        let radiusHistory = [];
        
        let runCount = 0; 
        let currentBaseHue = 0.66; 
        let isUserInteracting = false; 

        const K_GRAVITY = 3.0;
        const FRICTION_FACTOR = 0.95;
        const MIN_VELOCITY_THRESHOLD = 0.0001;
        const GRADIENT_DELTA_ANGLE = 0.01;
        const DOT_LERP_SPEED = 0.25; 
        const CAMERA_FOLLOW_LERP_SPEED = 0.08; // Slower LERP for camera auto-rotation

        const tempUnitVec = new THREE.Vector3(); 

        const MAX_TRAIL_SEGMENTS = 60;
        const TRAIL_SEGMENT_LIFETIME = 1.2; 
        const TRAIL_UPDATE_INTERVAL = 0.04; 
        let lastTrailUpdateTime = 0;
        const trailSegments = [];

        const sphereUpdate_tempVertex = new THREE.Vector3();
        const sphereUpdate_unitSpherePos = new THREE.Vector3();


        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff); 

            camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000); 
            camera.position.set(0, baseRadius * 0.5, baseRadius * 2.8);

            const canvas = document.getElementById('renderCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            
            const ambientLight = new THREE.AmbientLight(0xdddddd, 0.9); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); 
            directionalLight.position.set(1, 1.5, 1).normalize();
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4); 
            directionalLight2.position.set(-1, -0.5, -1).normalize();
            scene.add(directionalLight2);

            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05; 
            orbitControls.minDistance = baseRadius * 0.8;
            orbitControls.maxDistance = baseRadius * 5;
            orbitControls.target.set(0, 0, 0); 
            orbitControls.enablePan = false; 
            orbitControls.rotateSpeed = 0.1; 

            orbitControls.addEventListener('start', () => { 
                isUserInteracting = true; 
                // Target remains (0,0,0)
            });
            orbitControls.addEventListener('end', () => { 
                isUserInteracting = false; 
            });

            playerDot = createPlayerDot(); 
            if (playerDot) scene.add(playerDot);
            
            noisySphere = createNoisySphere(0); 
            if (noisySphere) scene.add(noisySphere);
            
            setupNewRun(); 

            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('resetButton').addEventListener('click', resetSimulation);
            
            onWindowResize(); 
            
            animationFrameId = requestAnimationFrame(animate); 
        }

        function setupNewRun() {
            simulationStartTime = performance.now();
            physicsLastTime = simulationStartTime;
            globalTimeSeconds = 0;
            radiusHistory = [];
            simulationRunning = true;
            isUserInteracting = false; 
            
            let dotHue;
            if (runCount === 0) {
                currentBaseHue = 0.66; 
                dotHue = 0.16;         
            } else {
                currentBaseHue = (currentBaseHue + 0.25) % 1.0; 
                dotHue = (currentBaseHue + 0.5) % 1.0;         
            }
            runCount++; 

            playerTheta = 0; 
            playerPhi = Math.PI / 2; 

            playerVelTheta = 0.0;
            playerVelPhi = 0.0;

            if (noisySphere) updateSphereGeometry(0); 
            if (playerDot) {
                const newDotColor = new THREE.Color().setHSL(dotHue, 0.95, 0.55);
                playerDot.material.color.copy(newDotColor);
                if (playerDotLight) playerDotLight.color.copy(newDotColor);
            }
            
            playerR = getHeightAt(playerTheta, playerPhi, 0); 
            lowestRadiusAchieved = playerR; 
            
            if(playerDot) playerDot.position.setFromSphericalCoords(playerR, playerPhi, playerTheta);
            
            orbitControls.target.set(0,0,0); 

            updateUIDisplays();
            document.getElementById('statsMenu').style.display = 'none';
        }

        function getNoiseValue(x, y, z, time) {
            let val = 0;
            const t = time * noiseEvolutionSpeed;
            const f1 = 8.0, f2 = 7.0, f3 = 10.4; 
            val += Math.sin(x * f1 + y * f2 + t * 1.1) * Math.cos(z * f1 + x * f3) * 0.4;
            val += Math.cos(y * f2 - z * f3 - t * 0.9) * Math.sin(x * f2 + y * f1) * 0.3;
            val += Math.sin(z * f3 + x * f1 - y * f2 + t * 1.3) * Math.cos(y * f3 - x * f2) * 0.3;
            val += Math.cos(x * 3.0 + t * 0.7) * Math.sin(y * 3.0 - t * 0.8) * 0.5; 
            val += Math.sin(z * 4.0 + t) * 0.3; 
            return val * 0.8;
        }

        function getHeightAt(theta, phi, time) {
            const safePhi = Math.max(0.0001, Math.min(Math.PI - 0.0001, phi));
            tempUnitVec.setFromSphericalCoords(1, safePhi, theta); 
            const noise = getNoiseValue(tempUnitVec.x, tempUnitVec.y, tempUnitVec.z, time);
            let r = baseRadius + noise * noiseAmplitude;
            return Math.max(0.1, r); 
        }

        function getColorForHeight(normalizedHeight) {
            const color = new THREE.Color();
            const saturation = 0.6 + normalizedHeight * 0.4; 
            const lightness = 0.4 + normalizedHeight * 0.3;  
            color.setHSL(currentBaseHue, saturation, lightness); 
            return color;
        }
        
        function createNoisySphere(initialTime) {
            const geometry = new THREE.SphereGeometry(baseRadius, 128, 64); 
            const positionAttribute = geometry.attributes.position;
            const colors = [];
            const minRForColor = baseRadius - noiseAmplitude;
            const maxRForColor = baseRadius + noiseAmplitude;

            for (let i = 0; i < positionAttribute.count; i++) {
                sphereUpdate_tempVertex.fromBufferAttribute(positionAttribute, i); 
                sphereUpdate_unitSpherePos.copy(sphereUpdate_tempVertex).normalize(); 
                const noise = getNoiseValue(sphereUpdate_unitSpherePos.x, sphereUpdate_unitSpherePos.y, sphereUpdate_unitSpherePos.z, initialTime);
                let currentRadius = baseRadius + noise * noiseAmplitude;
                currentRadius = Math.max(0.1, currentRadius);
                sphereUpdate_tempVertex.normalize().multiplyScalar(currentRadius);
                positionAttribute.setXYZ(i, sphereUpdate_tempVertex.x, sphereUpdate_tempVertex.y, sphereUpdate_tempVertex.z);
                const normalizedHeight = (currentRadius - minRForColor) / (maxRForColor - minRForColor);
                const vertexColor = getColorForHeight(Math.max(0, Math.min(1, normalizedHeight)));
                colors.push(vertexColor.r, vertexColor.g, vertexColor.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals(); 
            positionAttribute.needsUpdate = true; 
            const material = new THREE.MeshStandardMaterial({
                vertexColors: true, metalness: 0.05, roughness: 1.0, 
            });
            return new THREE.Mesh(geometry, material);
        }

        function updateSphereGeometry(currentTimeForNoise) {
            if (!noisySphere) return;
            const positions = noisySphere.geometry.attributes.position;
            const colors = noisySphere.geometry.attributes.color;
            const minRForColor = baseRadius - noiseAmplitude;
            const maxRForColor = baseRadius + noiseAmplitude;

            for (let i = 0; i < positions.count; i++) {
                sphereUpdate_tempVertex.fromBufferAttribute(positions, i);
                sphereUpdate_unitSpherePos.copy(sphereUpdate_tempVertex).normalize(); 
                const noise = getNoiseValue(sphereUpdate_unitSpherePos.x, sphereUpdate_unitSpherePos.y, sphereUpdate_unitSpherePos.z, currentTimeForNoise);
                let currentRadius = baseRadius + noise * noiseAmplitude;
                currentRadius = Math.max(0.1, currentRadius);
                sphereUpdate_tempVertex.copy(sphereUpdate_unitSpherePos).multiplyScalar(currentRadius); 
                positions.setXYZ(i, sphereUpdate_tempVertex.x, sphereUpdate_tempVertex.y, sphereUpdate_tempVertex.z);
                const normalizedHeight = (currentRadius - minRForColor) / (maxRForColor - minRForColor);
                const vertexColor = getColorForHeight(Math.max(0, Math.min(1, normalizedHeight))); 
                colors.setXYZ(i, vertexColor.r, vertexColor.g, vertexColor.b);
            }
            positions.needsUpdate = true;
            colors.needsUpdate = true;
            noisySphere.geometry.computeVertexNormals(); 
        }

        function createPlayerDot() {
            const dotGeometry = new THREE.SphereGeometry(0.12, 16, 8); 
            const dotMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 }); 
            const dotMesh = new THREE.Mesh(dotGeometry, dotMaterial);
            playerDotLight = new THREE.PointLight(0xffaa00, 2.5, baseRadius * 0.5); 
            dotMesh.add(playerDotLight); 
            return dotMesh;
        }

        function updatePlayerDotPosition() { 
            if (!playerDot) return;
            playerR = getHeightAt(playerTheta, playerPhi, globalTimeSeconds); 
            if (playerR < lowestRadiusAchieved) lowestRadiusAchieved = playerR;
            if (simulationRunning) radiusHistory.push(playerR);
            playerDot.position.setFromSphericalCoords(playerR, playerPhi, playerTheta);
        }
        
        function updateUIDisplays() {
            const percentComplete = Math.floor((globalTimeSeconds / RUN_DURATION_SECONDS) * 100);
            document.getElementById('runTimePercentDisplay').textContent = `${Math.min(100, Math.max(0,percentComplete))}%`;
            document.getElementById('currentRDisplay').textContent = playerR.toFixed(3);
            document.getElementById('lowestRDisplay').textContent = lowestRadiusAchieved === Infinity ? "N/A" : lowestRadiusAchieved.toFixed(3);
        }

        function applyGravity(deltaTime) {
            if (deltaTime <= 0) return;
            const h_current = getHeightAt(playerTheta, playerPhi, globalTimeSeconds); 
            const h_theta_plus = getHeightAt(playerTheta + GRADIENT_DELTA_ANGLE, playerPhi, globalTimeSeconds);
            const h_phi_plus = getHeightAt(playerTheta, playerPhi + GRADIENT_DELTA_ANGLE, globalTimeSeconds);
            let grad_R_dTheta = (h_theta_plus - h_current) / GRADIENT_DELTA_ANGLE;
            let grad_R_dPhi = (h_phi_plus - h_current) / GRADIENT_DELTA_ANGLE;
            let effectiveSinPhi = Math.sin(playerPhi);
            if (Math.abs(effectiveSinPhi) < 0.01) effectiveSinPhi = (effectiveSinPhi >= 0 ? 0.01 : -0.01);
            let acc_theta = -K_GRAVITY * grad_R_dTheta / (h_current * effectiveSinPhi);
            let acc_phi   = -K_GRAVITY * grad_R_dPhi / h_current;
            const max_acc_val = 10.0; 
            acc_theta = Math.max(-max_acc_val, Math.min(max_acc_val, acc_theta));
            acc_phi   = Math.max(-max_acc_val, Math.min(max_acc_val, acc_phi));
            playerVelTheta += acc_theta * deltaTime;
            playerVelPhi   += acc_phi * deltaTime;
            const friction = Math.pow(FRICTION_FACTOR, deltaTime * 60);
            playerVelTheta *= friction;
            playerVelPhi   *= friction;
            if (Math.abs(playerVelTheta) < MIN_VELOCITY_THRESHOLD) playerVelTheta = 0;
            if (Math.abs(playerVelPhi) < MIN_VELOCITY_THRESHOLD) playerVelPhi = 0;
            playerTheta += playerVelTheta * deltaTime;
            playerPhi   += playerVelPhi * deltaTime;
            playerPhi = Math.max(0.001, Math.min(Math.PI - 0.001, playerPhi)); 
            playerTheta = (playerTheta % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI); 
        }

        function updateTrail(deltaTime, currentTotalTimeInSeconds) {
            for (let i = trailSegments.length - 1; i >= 0; i--) {
                const segment = trailSegments[i];
                segment.age += deltaTime; 
                if (segment.age >= TRAIL_SEGMENT_LIFETIME) {
                    scene.remove(segment.mesh);
                    if (segment.mesh.geometry) segment.mesh.geometry.dispose();
                    if (segment.mesh.material) segment.mesh.material.dispose();
                    trailSegments.splice(i, 1);
                } else {
                    const lifeRatio = segment.age / TRAIL_SEGMENT_LIFETIME;
                    segment.mesh.material.opacity = 0.85 * (1.0 - lifeRatio * lifeRatio); 
                    segment.mesh.scale.setScalar(Math.max(0.05, 1.0 - lifeRatio * 0.85)); 
                }
            }
            const speed = Math.sqrt(playerVelTheta * playerVelTheta + playerVelPhi * playerVelPhi);
            const minSpeedForTrail = 0.01; 
            if (speed > minSpeedForTrail && (currentTotalTimeInSeconds * 1000 - lastTrailUpdateTime > TRAIL_UPDATE_INTERVAL * 1000 )) {
                 if (trailSegments.length >= MAX_TRAIL_SEGMENTS) {
                    const oldestSegment = trailSegments.shift(); 
                    scene.remove(oldestSegment.mesh);
                    if (oldestSegment.mesh.geometry) oldestSegment.mesh.geometry.dispose();
                    if (oldestSegment.mesh.material) oldestSegment.mesh.material.dispose();
                }
                const trailSegmentGeo = new THREE.SphereGeometry(0.06, 8, 4);
                const trailSegmentMat = new THREE.MeshBasicMaterial({
                    color: playerDot.material.color, 
                    transparent: true, opacity: 0.85 
                });
                const trailMesh = new THREE.Mesh(trailSegmentGeo, trailSegmentMat);
                trailMesh.position.copy(playerDot.position); 
                scene.add(trailMesh);
                trailSegments.push({ mesh: trailMesh, age: 0 });
                lastTrailUpdateTime = currentTotalTimeInSeconds * 1000; 
            }
        }

        function calculateStatistics() {
            if (radiusHistory.length === 0) return { min: lowestRadiusAchieved, max: 0, mean: 0, stdDev: 0 };
            const sum = radiusHistory.reduce((acc, val) => acc + val, 0);
            const mean = sum / radiusHistory.length;
            const max = Math.max(...radiusHistory);
            const squaredDifferences = radiusHistory.map(val => Math.pow(val - mean, 2));
            const variance = squaredDifferences.reduce((acc, val) => acc + val, 0) / radiusHistory.length;
            const stdDev = Math.sqrt(variance);
            return { min: lowestRadiusAchieved, max, mean, stdDev };
        }

        function showStatisticsMenu() {
            const stats = calculateStatistics();
            document.getElementById('statLowestR').textContent = stats.min.toFixed(3);
            document.getElementById('statMeanR').textContent = stats.mean.toFixed(3);
            document.getElementById('statStdDevR').textContent = stats.stdDev.toFixed(3);
            document.getElementById('statMaxR').textContent = stats.max.toFixed(3);
            document.getElementById('statsMenu').style.display = 'block';
        }

        function resetSimulation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            setupNewRun(); 
            animationFrameId = requestAnimationFrame(animate); 
        }
        
        function onWindowResize() {
            const canvasContainer = document.getElementById('canvasContainer');
            const appContainer = document.getElementById('sphereAppContainer');
            let availableWidth = appContainer.clientWidth - parseFloat(getComputedStyle(appContainer).paddingLeft) - parseFloat(getComputedStyle(appContainer).paddingRight);
            availableWidth = Math.min(600, availableWidth); 
            canvasContainer.style.width = availableWidth + 'px';
            canvasContainer.style.height = availableWidth + 'px'; 
            camera.aspect = 1; 
            camera.updateProjectionMatrix();
            renderer.setSize(availableWidth, availableWidth);
        }

        function animate(timestamp) {
            if (!simulationRunning) { renderer.render(scene, camera); return; }
            animationFrameId = requestAnimationFrame(animate); 
            
            const physicsDeltaTime = Math.min(0.1, (timestamp - physicsLastTime) * 0.001);
            physicsLastTime = timestamp;
            globalTimeSeconds = (timestamp - simulationStartTime) * 0.001; 

            if (globalTimeSeconds >= RUN_DURATION_SECONDS) {
                simulationRunning = false;
                globalTimeSeconds = RUN_DURATION_SECONDS; 
                updateSphereGeometry(globalTimeSeconds); 
                updatePlayerDotPosition(); 
                updateUIDisplays(); 
                showStatisticsMenu();
                // For the end screen, ensure camera looks at the final dot position while orbiting origin
                const endDistance = orbitControls.getDistance();
                camera.position.setFromSphericalCoords(endDistance, playerPhi, playerTheta);
                camera.lookAt(orbitControls.target); // Target is (0,0,0)
                renderer.render(scene, camera);
                return; 
            }
            
            orbitControls.update(); // Process user input and damping

            if (isUserInteracting) {
                // User is controlling the camera. Dot LERPs to view center.
                let targetPlayerTheta = (orbitControls.getAzimuthalAngle() % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);
                let targetPlayerPhi = orbitControls.getPolarAngle();
                targetPlayerPhi = Math.max(0.001, Math.min(Math.PI - 0.001, targetPlayerPhi));

                let deltaTheta = targetPlayerTheta - playerTheta;
                if (deltaTheta > Math.PI) deltaTheta -= 2 * Math.PI;
                if (deltaTheta < -Math.PI) deltaTheta += 2 * Math.PI;
                playerTheta += deltaTheta * DOT_LERP_SPEED;
                playerTheta = (playerTheta % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);
                playerPhi += (targetPlayerPhi - playerPhi) * DOT_LERP_SPEED;
                
                playerVelTheta = 0; 
                playerVelPhi = 0;
            } else {
                // User is idle. Apply physics.
                if (physicsDeltaTime > 0) {
                    applyGravity(physicsDeltaTime); // This updates playerTheta, playerPhi due to roll
                }
                // Camera auto-rotates to follow the new playerTheta, playerPhi
                const currentDistance = orbitControls.getDistance();
                const currentCamTheta = (orbitControls.getAzimuthalAngle() % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);
                const currentCamPhi = orbitControls.getPolarAngle();

                let targetCamTheta = playerTheta; // Camera should aim where the dot is
                let targetCamPhi = playerPhi;

                let deltaTheta = targetCamTheta - currentCamTheta;
                if (deltaTheta > Math.PI) deltaTheta -= 2 * Math.PI;
                if (deltaTheta < -Math.PI) deltaTheta += 2 * Math.PI;
                
                let newCamTheta = currentCamTheta + deltaTheta * CAMERA_FOLLOW_LERP_SPEED;
                newCamTheta = (newCamTheta % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);
                let newCamPhi = currentCamPhi + (targetCamPhi - currentCamPhi) * CAMERA_FOLLOW_LERP_SPEED;
                newCamPhi = Math.max(0.001, Math.min(Math.PI - 0.001, newCamPhi));

                camera.position.setFromSphericalCoords(currentDistance, newCamPhi, newCamTheta);
                camera.lookAt(orbitControls.target); // Target is always (0,0,0)
            }
            
            updateSphereGeometry(globalTimeSeconds);
            updatePlayerDotPosition(); // Update dot mesh to its final (aimed or rolled) position

            if (physicsDeltaTime > 0) { // Trail is based on rolling velocity
                 updateTrail(physicsDeltaTime, timestamp * 0.001); 
            }
            
            updateUIDisplays(); 
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>


```